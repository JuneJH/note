# Java基础

> 类和类之间的关系`is-a(继承 实现)` `has-a(组合 聚合 关联)` `use-a(need-a)(依赖)`
>
> Java面向对象是大特性:继承 封装 多态 （抽象）

## 1. Java 特性

- 跨平台(JVM--Java Virtual Machine): 以前跨芯片,现在跨操作系统
- 面向对象
- 简单性
- 健壮性
- 多线程
- 大数据开发相关

## 2. 数据类型

### 1. 基本数据类型

1. 整型
   - byte: 字节型 8个bit 第一位为符号位 范围-2的7次方～2的7次方-1(0表示0这个数)
   - short: 2字节16bit
   - int: 4字节32bit
   - long: 8字节64bit
2. 浮点型
   - float: 4字节32bit 首位表示符号，然后9个bit表示整数，后面小数
   - double: 8字节64bit 首位表示符号，然后19个表示整数，后面小数
3. 字符型
   - char: 2字节16bit
4. 布尔型
   - boolean 1bit ture false

### 2. 引用数据类型

1. 数组 []
2. 类/抽象类 class/abstract class
3. 接口 interface
4. 枚举 enum
5. 注解 @interface

### 3. 常量和变量

#### 1. 常量

1. 常量指程序运行过程中不能再次改变的值.
2. 基本类型的值固定不变
3. 特殊的常量比如String
4. final 修饰的

#### 2. 变量

1. 变量指在程序运行过程可以改变的
2. 变量指一个内存空间
3. 创建变量必须指定数据类型，变量空间名字
4. 变量空间只能存储一个内容(值或者引用)
5. 变量空间内容可以改变
6. jvm 开辟一个空间
7. 栈内存
8. 堆内存
9. 存储区 常量缓冲区，方法区，静态区
10. 常量通常使用32bit（int）和64bit（double）存储
11. 因此使用float a = 3.2F; long b = 3L;

### 4. 数据类型转换

1. 基本数据类型之间分为强制和自动转换
   - 强制转换可能会造成数据丢失，自动转换发生在同种数据类型且内存空间大于被转换空间
   - 浮点型和整形转换，比较精确程度，所以整形可以自动转浮点型
   - 字符与整形转换根据Unicode码
   - 布尔值不能发生转换，布尔值的空间为1bit
   - 运算符会自动提升数据类型，赋值运算符会自动转换数据类型截取
2. 引用类型之间转换分为上转型、下转型
3. 基本类型和引用类型转换需要借助包装类
   - Int--> Integer char-->Character long-->Long float-->Float

### 5. 运算

#### 1. 算术运算符

1. `+`,`-`,`*`,`/,%`,`++`,`--`
2. 会自动提升数据类型

#### 2. 赋值运算

1. `=`,`+=`
2. 如果后面是常量会自动对数据进行转换，如果是表达式需要强制转换

#### 3. 关系运算

1. `>`,`>=`,`<`,`<=`,`!=`,`==`,`Object instanceof Object`

### 4. 逻辑运算

1. &: 按位与
2. |: 按位或
3. ^: 异或
4. !: 逻辑非
5. &&: 短路与
   - 当第一个为false时才会发生短路，提高性能
6. ||: 短路或

#### 5. 位运算

1. `&`: 按位与
2. `|`: 按位或
3. `^`: 按位异或
4. `~`: 按位取反
5. `>>`: 按位右移
   - 相当于除以的2位移次幂的
   - 负数保留符号位原来是什么就是什么
6. `<<`: 按位左移
   - 相当于乘以的2位移次幂的
7. `>>>`: 按位右移(无符号)
   - 不保留符号位，补填0
8. 原码、补码、反码
   - 正数的三个码是一样的
   - 负数的反码是保持符号位不变其余位取反的
   - 负数的补码是反码加一
   - 计算机重存储的是补码

## 3. 语法结构

### 1. 顺序结构

### 2. 分支结构

- if(){}else{}
- if(){}else if(){}
- switch(){case;default}

### 3. 循环结构

- for(;;){}

#### 4. 转义字符

- \n: 换行
- \t: 制表符
- \r: 回车

## 4. 内存

1. JVM: 在内存中开辟一块儿空间
2. JVM开辟的空间分为栈内存,堆内存,存储区(常量缓冲区,方法区,静态元素区)
3. classLoader(类加载器),会把JVM编译好的类文件映射至方法区
4. 当new一个类时,会通过方法区的类文件映射作为模版创建一个对象

## 5. 修饰符

### 1. 权限修饰符

- public: 公共的权限最大
- protected: 受保护的
- 默认不写: 默认
- privete: 私有

### 2 .权限修饰符的区别

|           | 本类 | 同包 | 子类                | 当前工程 |
| --------- | ---- | ---- | ------------------- | -------- |
| public    | ✅    | ✅    | ✅                   | ✅        |
| protected | ✅    | ✅    | ✅(在子类的内部访问) |          |
| 默认不写  | ✅    | ✅    |                     |          |
| privete   | ✅    |      |                     |          |

### 3. 特征修饰符

- final: 不可更改的可用于修饰 变量 属性 方法(子类不可重写) 类(Math)
- static: 静态的,在加载类时加载(方法区,GC无法管理),可用于修饰类(内部类),方法,属性,程序块(static修饰的程序块在类加载是执行)
- abstract: 用于修饰类和方法,抽象方法无结构体必须存在抽象类中等待子类继承实现具体逻辑
- navtive: 修饰本地代码,执行体不可见
- transient: 序列化
- synchronized: 同步
- volatile: 不稳定
