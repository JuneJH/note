# 生成器

> Es2015标准推出生成器概念
> 可在函数外界控制函数得执行

## 1. 迭代器和迭代协议

> 遍历: 对一个数组,map,set等数据集合一次性依次拿出所有数据
> 迭代: 根据某种方式随时随地取出数据

1. 迭代器

- Es2015规定,一个对象如果具有next()方法,且该next方法返回一个对象,该对象并且具备以下属性
- value:此次数据得值
- done:bool 是否已经迭代完成

```js

 const iterator = {
            total:3,
            i:0,
            next(){
                return{
                    value:this.i > this.total ? undefined : this.i++,
                    done:this.i > this.total
                }
            }
        }

```

2. 迭代器创建函数

> 一个返回迭代器得安徽念书

```js

 function createIterator(total){
            let i = 0;
            return {
              next(){
                return {
                    value:i > total ? undefined : i++,
                    done:i > total
                }
            }
            }
        }

```

3. 可迭代协议

> 满足可迭代协议的对象可以使用ES2015```for...of```循环
> ```for...of```循环使用[Symbol.iterator]创建迭代器,利用迭代器进行循环

- 对象必须存在一个知名符号的属性`Symbol iterator`
- 该属性必须为一个无参的迭代器创建函数、
- 满足以上就满足了可迭代协议

```js
        // 可迭代
        function createIterator(){
            let i = 0;
            let total = 3;
            return {
              next(){
                return {
                    value:i > total ? undefined : i++,
                    done:i > total
                }
            }
            }
        }


        const iterators = {
            total:3,
            [Symbol.iterator]:createIterator
        }

       for (const iterator of iterators) {
            console.log(iterator)
        }
        const i = iterators[Symbol.iterator]();
        let result = i.next();
        while(!result.done){
            console.log("for...of原理",result.value)
            result = i.next();
        }

```

## 2. 生成器 Generator

> 通过Generator创建的对象,该对象既是一个迭代器(存在next())还是一个可迭代对象(拥有[Symbol.iterator])
> 但是Generator函数并非面向开发者,开发者无法使用该函数

1. 生成器函数 generator function

- 生成器函数用于创建一个生成器,只需要在function关键字后加上`*`即可

```js

   function* g1(){
       console.log("运行g1生成器");
       yield "done"
   }

   function* generator(){
            console.log("开始运行生成器函数");
            yield*g1();  // 在内部调用其他生成器方式
            let result = yield "第一结束返回";
            console.log("next传入参数",result);
            result = yield result;
            console.log("传入错误对象作为参数",result)
            return    // 提前结束该函数,不影响throw
            yield "error"
        }

        const g = generator(); // 调用该函数并不会执行函数内的代码,只是放回一个生成器
        let result = g.next(); // 开始执行函数内代码至第一个yield位置,并将yield后表达式的值返回
        console.log("",result); // {value: "第一结束返回", done: false}
        result = g.next("再次调用");// next的参数会作为yield的返回值形式给到函数内部，因此在第一次调用next方法是所带参数无意义,在未调用next时前面没有yield
        console.log("",result);// 得到yield表达式的值为自己传入参数
        result = g.next(new Error("我是错误对象"));//next()传入错误对象时,不影响内部函数执行
        g.throw();// throw()会导致函数内部发生一个错误

        // 可遍历
        for (const iterator of g) {
            console.log(iterator)
        }

```

- return 会提前结束生成器
- throw 会让生成器内部产生一个错误
- next 参数在第一次调用时失效
- yield 后表达式的值会赋值给此次调用的next函数