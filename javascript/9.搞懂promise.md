# 异步解决方案-Promise

> 回调地狱: Promise对象通过链式调用解决代码地狱问题
>
> 通过Promise方案实现时序、async/awiat方案解决异步问题

## 1. Promise基本概念

1. Promise内部具有三种状态
   - *pending*: 初始状态
   - *fulfilled*：兑现
   - *rejected*：拒绝
2. Promise.then() 是在异步环境执行,会被推入微任务队列
3. Promise.catch() 错误会被传递到catch中

## 2. 创建一个Promise

1. 创建一个Promise

   ```js
   const  p = new Promise((resolve,reject)=>{
        console.log("run Prmise");
        setTimeout(()=>{
            console.log("runnn")
            resolve("ok"); // 内部状态变成 fulfiiled
         // reject("err")  // 内部状态变成 rejected 
        })
   })
   ```

2. 使用静态方法创建

   ```js
   Promise.resolve(); // 快速创建一个内部状态为fulfiiled
   Promise.reject();  // 快速创建一个内部状态为reject
   ```

3. 实现一个时序方案

   ```js
   [func1, func2, func3].reduce((p, f) => p.then(f), Promise.resolve())
   .then(result3 => { console.log(result3) });
   ```


## 3. 链式调用

1. then方法必定返回一个新的Promise(后续处理也是一个任务)

2. 新任务的状态取决于后续处理

   1. 若没有相关(比如前面是正常的Promise，后续没有传入正常处理的回调，如果是失败的Promise，后续没有catch)后续处理，新任务的状态和前任务一致，数据为前任务的数据
   2. 若后续处理但未执行，新任务挂起
   3. 若后续任务处理执行了，则根据后续处理的情况确定新任务的状态
      1. 后续处理执行无错，新任务的状态为完成，数据为该处理函数的返回值
      2. 后续处理执行出现错误，新任务的状态为失败，数据为异常对象
      3. 后续执行返回一个Promise对象，新任务的状态和数据与该Promise一致

3.  catch后一切按照正常流程走 

   ```javascript
   const p = Promise.resolve().then(()=>{
     throw 3;// null.toString();
   }).catch((res)=>{
     return 5;
   })
   // p 是一个Promise {<fulfilled>: 5} 成功Promise对象

4. 因为有以上规则所以平时常见使用方案

   ```javascript
   const promise = new Promise(()=>{})
   
   promise.then().catch() // 如果promise是reject的，因为在第二步then中并没有处理错误，所以第二步的状态和promise是一致的，所以才能被catch到
   
   promise.then().then() // 任务成功依次执行
   
   promise.then().then().catch(); // 最终任意一步出现错误因为上面规则第一条都会被catch到
   ```

   

## 3. Promise静态方法

1. Promise.all(任务数组)

   1. 返回一个任务它的状态是全部成功则成，一个失败则失败

   ```js
   // 如果所有都成功即没有任何错误,则then产生新的Promise内部状态为fulfiiled,如果又一个失败则为reject并且第一个失败的错误信息作为它的错误信息
   Promise.all([func1(), func2(), func3()])
   .then(([result1, result2, result3]) => {console.log("res ",result1,result2,result3)});
   ```

2. Promise.any(任务数组)

   1. 返回一个任务它的状态是任一成功则成，全部失败则失败

3. Promise.allSettled(任务数组)

   1. 返回一个任务，任务数组全部已决 则成功，该任务不会失败

4. Promise.race(任务数组)

   1. 返回一个任务，任务数组任一已决则已决，状态和其一致

   ```js
   // 新的Promise对象把第一个完成的状态作为自己成功完成的状态
   Promise.race([func1(), func2(), func3()]).then(res=>{
        console.log("res",res)
   })
   ```

   - Promise 超时,取消，通过setTImeout手动构造一个失败的Promise，超时直接reject

     ```javascript
     Promise.race([promise,new Promise((resolve,reject)=>setTimeout(()=>{reject()}),timer)])
     ```

5. Promise.allSettled(); 无论成功失败都会返回

6. Promise.any

7. Promise.resolve()

   ```js
   new Promise(resolve=>resolve(data)) // 等价
   Promise.resolve(data); // 快速创建一个内部状态为fulfiiled
   ```

8. Promise.reject()

   ```js
   new Promise((resolve,reject)=>reject(reason))
   Promise.reject(reason);  // 快速创建一个内部状态为reject
   ```

## 4. 手写一个Promimse

```js
unction MyPromise(executor) {
  this.promiseState = 'pending';
  this.promiseValue = 'undefined';
  this.thenList = [];
  this.catchList = [];
  this.changeState = (data, state, queue) => {
    if (this.promiseState != "pending") return;
    this.promiseState = state;
    this.promiseValue = data;
    queue.forEach(ele => {
      ele(data);
    })

  }
  const resolve = (data) => {
    this.changeState(data, 'resolved', this.thenList)
  }
  const reject = (data) => {
    this.changeState(data, 'rejected', this.catchList)

  }
  try {
    executor(resolve, reject);
  } catch (err) {
    reject(err);
  }

  this.then = (thenable, catchable) => {
    // catchable && this.catch(catchable)
    return new MyPromise((resolve, reject) => {
      const newThenable =function (data)  {
        try {
          const result = thenable(data)
          if(result instanceof MyPromise){
            result.then(res=>{
              resolve(res)
            },err=>{
              reject(err)
            })
          }else{
            resolve(result);
          }

        } catch (err) {
          reject(err)
        }
      }
      if (this.promiseState == 'resolved') {
        newThenable(this.promiseValue)
      } else {
        this.thenList.push(newThenable)
      }
      const newCatchable = function (err) {
        try {
          const result = catchable(err);
          if(result instanceof MyPromise){
            result.then(res=>{
              resolve(res)
            },err=>{
              reject(err)
            })
          }else{
            resolve(result)
          }

        } catch (err) {
          reject(err)
        }
      }
      if (this.promiseState == 'rejected') {
        newCatchable(this.promiseValue)
      } else {
        this.catchList.push(newCatchable)
      }

    })
  };
  this.catch = (catchable) => {
    return new MyPromise((resolve, reject) => {
      const newCatchable = function (err) {
        try {
          const result = catchable(err);
          if(result instanceof MyPromise){
            result.then(res=>{
              resolve(res)
            },err=>{
              reject(err)
            })
          }else{
            resolve(result)
          }

        } catch (err) {
          reject(err)
        }
      }
      if (this.promiseState == 'rejected') {
        newCatchable(this.promiseValue)
      } else {
        this.catchList.push(newCatchable)
      }
    })
  }
}

MyPromise.all = function(iterable){
  return new MyPromise((resolve,reject)=>{
    const result = iterable.map(p=>{
      const obj = {
        data:null,
        isSettle:false,
      }
      p.then(res=>{
        obj.data = res;
        obj.isSettle = true;
        const re = result.filter(p=>!p.isSettle)
        if(re.length == 0){
          resolve(result.map(p=>p.data));
        }
      },err=>{
        reject(err)
      })
      return obj;
    })

    })

}
MyPromise.race = function(iterable){
  return new MyPromise((resolve,reject)=>{
    iterable.forEach(p=>{
      p.then(res=>{
        resolve(res)
      },err=>{
        reject(err)
      })
    })
  })

}
MyPromise.resolve = function(params){
  if(params instanceof MyPromise){
    return params;
  }else{
    return new MyPromise((resolve)=>{
      resolve(params)
    })
  }

}
MyPromise.reject = function(params){
  return new MyPromise((resolve,reject)=>{
    reject(params)
  })

}
```

