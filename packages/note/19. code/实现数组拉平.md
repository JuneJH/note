# flatten

> 在`ECMAScript 2019`中推出`Array.prototype.flat([depth])`方法用于拉平数组
> 所需参数代表需要拉平几层

## 1. 使用[].flat()

> 该方法在数组的原型上，数组可直接调用
> 参数默认为一层，如果想要拉平所有可以传递一个无限大的树(`Infinity`)

```js
const arr = [1, 2, 3, 4, 5, [6, 7, 8, 9, [10, 11, 12, [13, 14, 15]]]];
console.log(arr.flat(5)); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
```

**该方法毕竟`ECMAScript 2019`推出，是一个较新的方法**

## 2. 替代方案reduce

> 利用数组`reduce`和`...`扩展运算符实现

```js
function flattenReduce(arr, depth = 1) {
  return arr.reduce((curr, ele) => {
    if (Array.isArray(ele)) {
      if (depth-- > 0) {
        curr.push(...flattenReduce(ele, depth));
      } else {
        curr.push(ele);
      }
    } else {
      curr.push(ele);
    }
    return curr;
  }, []);
}
```

1. 使用

```js
const arr = [1, 2, 3, 4, 5, [6, 7, 8, 9, [10, 11, 12, [13, 14, 15]]]];
console.log(flatten(arr,5)); // [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
```

- 思路就是这么个思路，可以选择其他遍历数组的方法，其他展开数组的方案

## 3. 来自MDN上非递归方案

> 利用堆栈的特点，


```js
function flatten(input) {
  const stack = [...input];  // 利用堆栈
  const res = [];             // 最终结果容器
  while (stack.length) {  
    const next = stack.pop(); // 使用pop()性能更高一点
    if (Array.isArray(next)) {
      stack.push(...next);    // 【核心】利用扩展运算符实现拉平
    } else {
      res.push(next);
    }
  }
  // 反转恢复原数组的顺序
  return res.reverse();     // 前面使用的是pop()导致数组顺序相反
}
```

- 通过什么方式循环数组会得到不同的结果(对空位的处理)
- 通过什么方式展开数组(扩展运输符,遍历...)

