# 设计模式

1. 解决复杂问题
   1. 简单问题没必要使用设计模式
   1. 多用于公共库或复杂的业务需求
2. 提升代码质量
   1. 可维护性
   2. 可扩展性
4. 设计模式就是在**面向对象**软件设计过程中针对特定问题的简洁而优雅的解决方案-最佳实践

## 1. 设计模式原则

1. 封装变化的内容(找出程序中变化的地方，并将变化封装起来)
   1. 方法层面封装(一个函数内需要计算一些变化的东西，应该把这部分封装为一个方法，后期变化无需改变该函数**开闭原则**) 
   2. 类层面封装
2. 面向接口开发（依赖倒置）
3. 组合优于继承

### 1. 单一职责原则（Single Responsibility Principle）

1. 一个类应该只有一个引起它变化的原因，一个类应该只负责一项任务，如果不遵循单一职责原则，在修改一个功能的时候可能就会影响到其他功能
2. 只有在职责确定要发生变化的时候分离才有意义，两个职责耦合在一起但并没有发生变化的征兆也就没必要分离
3. 平衡单一原则使用场景，根据具体的场景具体实践
4. 类和模块的设计

### 2. 开闭原则（Open Closed Principle）

1. 鼓励通过扩展来添加新的功能，而不是修改已有代码，这样可以减少因为修改旧代码引入新错误的风险
2. 策略模式: 通过维护一个规则，封闭调用，扩展规则
3. 对修改关闭，对扩展开启
4. 主要关注如何设计系统以便添加新功能时不需要修改已有代码

### 3. 里氏替换（Lishkov Substitution Principle）

1. 如果类S是类T的子类，那么类型T的对象可以被类型S的对象替换（即类型S的对象可以作为类型T的对象使用，并且保证原来程序的逻辑行为不变）
2. 第三方库提供一些基类，外部通过继承基类扩展
3. **每个子类需要正确实现父类的接口，并且不能改变父类接口的预期行为**

### 4. 接口隔离(Interface Segregation Principle)

1. 规定不应该强迫用户去依赖他们不使用的接口
2. 在设计接口时需要将一个臃肿的接口进行分割，分割成更小的更具体的接口
3. 接口设计

### 5. 依赖倒置（Dependency Inversion Principle）

1. 高层模块(包含业务逻辑或者系统核心部分)不应该依赖低层(与数据库交互)的实现细节，两者都应该依赖于中间的抽象层(接口或者抽象类)
2. 抽象不应该依赖细节，细节应该依赖抽象
3. 面向接口编程，比如后端3层
4. 主要关注与如何组织依赖关系以减少模块间的耦合

### 6. 最小知识原则（Principle of Least Knowledge）*迪米特法则*

1.  在设计软件实体(函数、类、模块、组件...)时，要尽量减少两者之间的相互了解，只与最直接的朋友进行通信，避免和更远的实体(间接朋友)进行通信
2. 每个单元应该只与它的直接朋友(在同一模块内或通过参数传递进来的对象)交流
3. 每个单元应该可能少的来了解与他交流的其他单元，不要操作内部实现细节方法或属性
4. 尽可能减少单元间的交流，当多个模块需要交互时，应该通过简单接口进行，避免复杂的交互模式
5. 只与最近的朋友交谈，避免调用更远的关系链上的方法

## 2. 面向对象补充

### 1. 类(模版/蓝图)和对象

1. 针对某一类事物的属性和行为的抽象
2. 描述一个类的时候可以使用UML类图(unified modeling language 统一建模语言)
3. 对象就是根据类来创建的具体实例，称为实例对象，一个实例对象拥有类中定义的属性和方法

### 2. 抽象

1. 提取关键点
2. 抽象是程序设计中一种计算思维，将关键部分从细节中分离出来，忽略不必要的细节，只关注关键的方面
3. 针对一个事物之需要关注特定的属性和特定的行为，其他不重要的直接忽略掉

### 3. 封装

1. 通过存取器获取 
2. 隐藏内部细节，不直接暴露给外部，可通过权限修饰符/闭包实现
3. 通过存取器间接操作(getter/setter)

### 4. 继承

1. 在面向对象中，继承是一种允许新创建的类继承另一个类的属性和方法的机制，通过继承，子类自动包含了父类的所有属性和方法(不能继承私有成员)
2. 组合模式/圣杯模式
3. ES6的class通过extend实现

### 5. 多态

1. OOP中的多态性是指允许不同类的对象对同一消息做出响应的能力，即同一个接口可以被不同的对象以不同的方式实现，多态的存在使的对象可以在内部实现细节的不同情况下共享外部接口

2. 多态最常见是通过继承实现的子类多态，其中子类需要重新实现父类的方法，从而实现相同接口不同的行为

3. 函数重载也可以是多态的一种体现

4. Js是弱类型语言，天生就是多态

   ```js
   const cat = {
     name:"cat",
     say(){
       console.log("hello i am a cat");
     }
   }
   const dog = {
     name:"dog",
     say(){
       console.log("hello i am a dog");
     }
   }
   // 同一接口可以不同对象以不同的方式实现
   function say(animal){
     return animal.say();
   }
   
   say(cat);
   ```

5. Typescript中使用鸭子类型，鸭子类型指导我们只关注对象的行为，而不关注对象本身 

### 6. 抽象类 Where do you come from

1. 一种特殊的类，无法直接实例化它
2. 在抽象类中包含一些抽象方法，即只有方法签名，没有方法实现
3. 一个子类继承了抽象类，那么必须要实现抽象类里面所有的方法
4. 一个子类在继承了抽象类后，没有实现父类(抽象类)的抽象方法，那么这个子类也必须是一个抽象类
5. 抽象类主要目的是为其他类提供一个基础的可扩展的框架，具体的实现细节由抽象类的子类来决定
6. 在一个抽象类中，可以定义抽象方法，不存在抽象属性的说法，但是可以定义抽象的getter/setter
7. 抽象类背后的思想是继承

### 7. 接口 What ability do you have

1. 接口通常用来定义一个对象可以有哪些属性和方法，但它不关心这些方法和属性的实现细节
2. 一个类可以实现多个接口
3. 接口代表的思想是组合

## 3. 设计模式分类

> 根据意图或者目的进行分类

### 1. 创建型（创建对象的机制，增加已有代码的灵活性和复用）

- 单例模式
- 工厂方法模式
- 抽象工程模式
- 建造者模式
- 原型模式

### 2. 结构型（如何将对象和类组装成较大的结构，并同时保持结构的灵活和高效）

- 适配器模式
- 装饰者模式
- 代理模式
- 外观模式
- 桥接模式
- 组合模式
- 享元模式

### 3. 行为型（负责对象间高效沟通和职责分配）

- 观察者模式
- 策略模式
- 模版模式
- 责任链模式
- 解析器模式
- 迭代子模式
- 命令模式
- 状态模式
- 备忘录模式
- 访问者模式
- 中介者模式

