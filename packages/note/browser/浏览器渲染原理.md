# 浏览器渲染原理

> 知晓浏览器渲染原理能够帮助我们更好完成性能优化、自信的设计架构工程。常见的面试题为：1. 请问从URL到浏览器展示出页面，浏览器做了哪些工作。

## 1. 工作单元

### 1. 浏览器主进程

### 2. 网络进程

### 3. 渲染进程（沙盒隔离）

#### 1. 渲染主线程

##### 1. HTML解析

1. 解析HTML Parse
   1. 获得一颗DOM树
   2. CSS解析
      1. 获得一颗CSSOM树
      2. 使用`document.styleSheets`操作用户样式表
      3. 启动预解析线程优先下载（网络线程）和解析css
      4. 不会阻塞HTML解析
   3. JS解析，渲染主线程遇到JS时必须暂停解析，等待下载执行完后才能继续，同理预解析线程可参与下载js任务
      1. 因为js 代码可能会改动HTML，因此需要暂停等待执行
2. 样式计算 Computer Style
   1. css属性的计算过程（补齐视觉格式化模型，盒模型和包含块流式布局）
      1. 层叠
      2. 集成
3. 布局 Layout
   1. 此时会生成Layout树，但是Layout树不一定和DOM树一一对应
   2. Layout树是显示到页面上的具体元素，比如设置了`display:none`的元素就不会出现在这个树中，比如伪元素就会出现在Layout树中。（另外在浏览器默认样式表中为一些标签设置了dispaly:none属性，因此他们也不可见，也就不再该树中）
   3. 内容必须在行盒中,因此我们直接使用`<p>text</p>`，text前会有一个匿名行盒
   4. 行盒和块盒不能相邻，因此会包一层匿名块盒

4. 分层 Layer
   1. 浏览器为了避免过度重新绘制，采用分层优化
   2. 堆叠上下文会影响分层结果
   3. will-chang:transfer; 较大能影响分层结果
   4. 浏览器中可以通过工具 layer查看分层结果

5. 绘制 Paint
   1. 首先会生成不同指令，类似canvas
   2. 交给合成线程


#### 2. 合成线程

6. 分块 Tiling
   1. 分块会将每一层分为多个小的区域
   2. 利于后期优化，比如优先绘制视口
7. 光栅化 Raster
8. 画 Draw

## 2. 常见疑惑

### 1. Css加载会阻塞浏览器渲染吗

1. 不会，因为css加载会在预解析线程完成，预解析线程完成后会讲此过程包装为一个任务等待渲染主线程执行组装CSSOM树

### 2. Js加载会阻塞浏览器渲染吗，为什么要建议把script标签放在body标签后

	1. 会阻塞
	2. 并不是说 script 标签必须放在底部，因为你可以给script 标签添加 defer 或者 async 属性。
	 当 script 标签加上 defer 属性以后，表示该 JS ⽂件会并⾏下
	 载，但是会放到 HTML 解析完成后顺序执⾏，所以对于这种情况你
	 可以把 script 标签放在任意位置。
	 对于没有任何依赖的 JS ⽂件可以加上 async 属性，表示 JS ⽂件下
	 载和解析不会阻塞渲染。

### 3. transfer为什么性能高

1. 因为transform既不会影响布局也不会影响绘制指令，它影响的只是渲染流程的最后一个draw阶段
2. 由于draw阶段在合成线程中，所以transform的变化几乎不会影响到渲染主线程，即渲染主线程被阻塞也不会影响tranform的变化
3. 像这样的处理，还有滚动

#### 4. 为什么div、p标签是块盒

1. 因为在用户样式表中，手动设置了`display:block`；
2. 这也就解释了HTML是负责语义化，CSS负责样式

#### 5. 什么是reflow

1. reflow的本质就是重新计算Layout树
2. 当进行了会影响布局树的操作后，需要重新计算布局树，会触发layout
3. 为避免连续多次操作导致布局树反复计算，浏览器会合并这些操作当js代码全部完成后再进行统一计算，因此改动属性造成的reflow是异步完成的（vue、react的批处理）
4. 但是如果获取属性就无法获取最新的布局信息，因此获取属性需要立即reflow

#### 6. 什么是repaint

1. repaint 的本质就是重新根据分层信息计算绘制指令
2. 当改动了可见样式后，就需要重新计算，会引发repaint
3. 由于元素的布局信息也属性可见样式，所以reflow一定会引发repaint

## 3. 参考

1. 当浏览器的网络线程收到HTML文档后，会产生一个渲染任务，并将其传递给渲染主线程的消息队列，在事件循环机制的作用下，渲染主线程取出消息队列中的渲染任务，开启渲染流程
2. 整个渲染流程分为多个阶段，分别是：HTML解析、样式计算、布局、分层、绘制、分块、光栅化、画。每个阶段都有明确的输入输出，上一个阶段的输出会成为下一阶段的输入。
3. 解析HTML
   1. 解析过程中遇到css解析css，遇到js执行js，为了提高解析效率，浏览器再开始解析前，会启动一个预解析的线程，率先下载HTML中的外部CSS文件和外部的JS文件
   2. 如果主线程解析到link位置，此时外部CSS文件还没有下载解析好，主线程不会等待，继续解析后续的HTML，这是因为下载和解析CSS的工作是在预解析线程中进行的，这就是CSS不会阻塞HTML解析的根本原因
   3. 如果主线程解析到script位置，会停止解析HTML，等待js文件下载好，并将全局代码解析执行完成后，才能继续解析HTML。这是因为JS代码执行过程中可能会修改当前的DOM树，所以DOM树的生成必须等待
   4. 此步骤会得到DOM树和CSSOM树，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在CSSOM树中
4. 样式计算，会得到一颗带样式的DOM树
   1. 主线程会遍历得到DOM树，依次为树中的每个节点计算出它最终的样式，称之为 `Computed Style`。
   2. 在这一过程中，很多预设值会变成绝对值，比如red会变成rgb(255,0,0);相对单位会变成绝对单位，比如em变成px
   3. 这一步之后，会得到一颗带有样式的DOM树
5. 布局，布局之后得到布局树Layout 树
   1. 布局阶段会依次遍历DOM树的每一个节点，计算每一个节点的几何信息，比如节点的宽高、相对包含块的位置
   1. 大部分时候，DOM树和布局树并非一一对应，比如display:none的节点没有任何几何信息，因此不会生成到布局树；又比如使用了伪元素选择器，虽然DOM树中不存在这些伪元素节点，但是他们拥有几何信息，所以会生成到布局树中，还有匿名行盒、匿名块盒都会导致DOM树和Layout树无法一一对应
6. 分层
   1. 主线程会使用一套复杂的策略对整个布局树中进行分层
   2. 分层的好处在于，将来某一个层改变后，仅会对该层进行后续处理，从而提升效率
   3. 滚动条、堆叠上下文、transform、opacity等样式都会或多或少影响分层结果，也可以通过will-change属性更大程度影响分层结果

7. 绘制
   1. 主线程会为每个层单独产生绘制指令集，用于描述这一层的内容该如何绘制
   2. 完成绘制后，主线程将每个图层的绘制信息交给合成线程
   3. 合成线程会对每个图层进行分块，将其划分为更多小区域
   4. 并且会在线程池中调用多个线程来完成分块工作

8. 光栅化-输出一块一块的位图
   1. 合成线程会将信息交给GPU进程（GPU加速），以极高的速度完成光栅化
   2. GPU进程会开启多个线程来完成光栅化，并优先处理靠近视口区域的块

9. 画
   1. 合成线程拿到每个层、每个块的位图后，生成一个个的指引quad信息
   2. 指引会标识出每个位图应该画到屏幕那个位置，以及会考虑旋转、缩放等变形
   3. 变形发生在合成线程，与渲染主线程无关，这就是transform效率高的本质原因
   4. 合成线程会把quad提交给GPU进程(渲染进程因为沙盒隔离，无法直接与硬件通信，所以通过GPU进程控制 )，由GPU进程产生系统调用，提交给GPU硬件完成最终渲染


