# 策略模式(Strategy)

> 一个类中有一个处理流程针对不同对象都是一致的,那么有多少个对象就需要创建多少个对应方法来完成该流程
>
> 利用多态实现接受不同类型参数

## 1. 利用抽象类实现策略模式

1. 需要做相同流程的类一

```java
public class Woman extends Person{

    public Woman(String name){
        this.name = name;
    }
    public void wakeUp(){
        System.out.println(this.name+"起床化妆");
    }

    @Override
    public void goOut() {
        System.out.println(this.name + "整理衣服准备出门了");
    }

    @Override
    public void sleep() {
        System.out.println(this.name+"卸妆准备睡觉了");
    }
}
```

2. 需要做相同流程的类二

```java
public class Man extends Person{
    public Man(String name){
        this.name = name;
    }
    public void wakeUp(){
        System.out.println(this.name+"睡过去了,等待下一个闹钟叫醒");
    }

    @Override
    public void goOut() {
        System.out.println(this.name + "拿着外套出门了");
    }

    @Override
    public void sleep() {
        System.out.println(this.name+"直接睡觉了");
    }
}

```

3. 抽象以上两个类形成一个父类

```java
public abstract class Person {

    protected String name;
    public abstract void wakeUp();

    public abstract void goOut();

    public abstract void sleep();

}
```

4. 实现规则

```java
public class ManagePerson {

    public void day(Person person){
        System.out.println("======欢迎开启打工的一天=====");
        person.wakeUp();
        person.goOut();
        person.sleep();
        System.out.println("======早点休息吧,打工人======");

    }
}
```

5. 测试

```java
public class Test {
    public static void main(String[] args) {
        Person woman = new Woman("小花");
        Person man = new Man("小萨");

        ManagePerson mp = new ManagePerson();

        mp.day(woman);

        mp.day(man);
    }
}
```

- 可以看到`day`方法可以接受不同的参数,这些参数发生向上转型
- 重载也可以接受不同参数,重载需要写很多个同样方法名的方法
- 多态不需要

## Typescript实现案例

1. 通过策略模式实现一个根据用户需求选择合适的渲染器

2. 定义接口

   ```typescript
   export interface IData {
       name: string
   }
   export interface IRenderer {
   
       render(data: IData): React.ReactElement;
   }
   ```

3. 定义策略

   ```typescript
   import type { IRenderer, IData } from "../interface";
   
   class OrangeRenderer implements IRenderer {
     render(data: IData): React.ReactElement {
       return <div style={{ color: "orange" }}>{data.name}</div>;
     }
   }
   
   
   class RedRenderer implements IRenderer {
     render(data: IData): React.ReactElement {
       return <div style={{ color: "red" }}>{data.name}</div>;
     }
   }
   
   class YellowRenderer implements IRenderer {
     render(data: IData): React.ReactElement {
       return <div style={{ color: "yellow" }}>{data.name}</div>;
     }
   }
   
   ```

4. 定义中间层

   ```typescript
   import type { IData, IRenderer } from './interface';
   class Context {
       private strategy: IRenderer;
       constructor(st: IRenderer) {
           this.strategy = st;
       }
   
       setStrategy(st: IRenderer) {
           this.strategy = st;
       }
   
   
       render(data: IData) {
           return this.strategy.render(data);
       }
   
   
   }
   
   export default Context;
   ```

5. 使用

   ```typescript
   import { useCallback, useRef, useState, type FC } from "react";
   import Context from "./strategy/Context";
   import OrangeRenderer from "./strategy/renderer/OrangeRenderer";
   import YellowRenderer from "./strategy/renderer/YellowRenderer";
   import RedRenderer from "./strategy/renderer/RedRenderer";
   
   const Strategy: FC = () => {
     const [strategy, setStrategy] = useState<string>();
     const [content, setContent] = useState<string>("默认渲染内容");
   
     const rendererRef = useRef(new Context(new RedRenderer()));
   
     const onInputChange = useCallback(
       (e: React.ChangeEvent<HTMLInputElement>) => {
         setContent(e.target.value);
       },
       []
     );
     const onSelectChange = useCallback(
       (e: React.ChangeEvent<HTMLSelectElement>) => {
         const type = e.target.value;
         setStrategy(type);
         switch (type) {
           case "red":
             rendererRef.current.setStrategy(new RedRenderer());
             break;
           case "yellow":
             rendererRef.current.setStrategy(new YellowRenderer());
             break;
           case "orange":
             rendererRef.current.setStrategy(new OrangeRenderer());
             break;
         }
       },
       []
     );
   
     return (
       <div>
         <div>
           请输入渲染内容：
           <input value={content} onChange={onInputChange} />
         </div>
         <div>
           选择渲染策略：
           <select value={strategy} onChange={onSelectChange}>
             <option value="red">红色渲染</option>
             <option value="orange">橘色渲染</option>
             <option value="yellow">黄色色渲染</option>
           </select>
         </div>
   
         <div>渲染模块：{rendererRef.current.render({ name: content })}</div>
       </div>
     );
   };
   
   export default Strategy;
   
   ```

   

